<?xml version="1.0" encoding="UTF-8"?>
<!-- Please make sure the XInclude support in enabled! -->
<!-- To do that check that the Enable XInclude processing option is enabled in the -->
<!-- XML - XML Parser Properties page in the application Options/Preferences dialog -->

<!-- 
    <link xl:href="images/roles.png" xl:show="new" xl:title="click to view larger image" >
    <inlinemediaobject>
    <imageobject role="html">
    <imagedata fileref="images/roles-small.png" align="center"/>
    </imageobject>
    </inlinemediaobject>
    </link>
    
    <mediaobject>
    <imageobject role="html">
    <imagedata fileref="images/roles-small.png" align="center"/>
    </imageobject>
    </mediaobject>   
    
-->

<!DOCTYPE vars [
        <!ENTITY attic "Attic">
        <!ENTITY adics "ADICS">
        <!ENTITY home "&lt;attic-home-directory&gt;">
        ]>
<article xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xl="http://www.w3.org/1999/xlink">

    <title>Attic User and Developer Guide</title>

    <sect1 xmlns="http://docbook.org/ns/docbook" version="5.0"
           xmlns:xl="http://www.w3.org/1999/xlink">
        <title>Introduction</title>


        <para>This document provides an overview of &attic;. It is primarily intended for users
            as well as developers who want to extend the functionality of the code. &attic; is
            developed for the EU
            <link xl:show="new" xl:href="http://www.edges-grid.eu/">EDGeS
            </link>
            project. It implements the architecture defined by Peer-to-Peer Architecture for
            Data-Intensive Cycle Sharing (&adics;). An understanding of the background to
            &adics;, its overall architecture and context is presumed. For high-level documents
            about &adics; and other supporting information, please refer to<link xl:show="new"
                                                                                 xl:href="http://www.atticfs.org">http://www.atticfs.org</link>.
        </para>
        <para>The description of the code in this document describes &attic;
            <emphasis>as it
                stands at the time of writing
            </emphasis>
            (June 2009). The code is still in a pre
            version 1.0 state. Furthermore, The code base is relatively small, making refactoring
            that affects the API tempting to those who feel it is needed.
        </para>
        <para>The aim of &attic; is to be very lightweight, easy to configure and easy to run.
            With this in mind, the core code has no third party dependencies, supports Web
            configuration and contains a number of classes in the test directory with examples of
            how to run the different roles involved in an &adics; network.
        </para>
        <para>Although &adics; is not strictly tied to HTTP, &attic; uses HTTP exclusively,
            both for control messages and for data transfer. &attic; is not tied to a particular
            HTTP implementation. The current implementation uses HttPeer, another Cardiff project.
            HttPeer is a very lightweight library that allows easy server- and client-side HTTP data
            transfers. The
            <link xl:href="http://www.restlet.org/" xl:show="new">Restlet</link>
            framework would also make a suitable HTTP back end to the code, although it is a larger
            code base, and some of the optimizations and security features could be harder to
            implement (being a third party library).
        </para>

        <sect2>
            <title>Useful Links</title>
            <itemizedlist>

                <listitem>
                    <para>The code is available from
                        <link xl:show="new"
                              xl:href="https://svn.cs.cf.ac.uk/projects/attic/trunk/"/>
                        and can be
                        downloaded using a Subversion client. The build uses Apache's<link
                                xl:show="new" xl:href="http://maven.apache.org/">Maven</link>. The core
                        code has a number of first-party dependencies. During the maven build, in
                        particular the
                        <code>package</code>
                        goal, a JAR file containing these
                        dependencies is generated in the
                        <code>all/</code>
                        directory of the
                        <code>core</code>
                        module. This JAR file
                        (<emphasis>attic-all-&lt;version&gt;.jar</emphasis>) contains
                        all the code needed to run core &attic; without any other dependencies.
                    </para>
                </listitem>
                <listitem>
                    <para>Binary versions are available from<link
                            xl:href="http://www.trianacode.org/maven/org/atticfs/">
                        http://www.trianacode.org/maven/org/atticfs/</link>. The binaries are
                        laid out according to the maven repository format, so the link above points
                        to the main directory. Versions are available under the version directories
                        (e.g., 0.1/, 0.2/ etc.), as well as maven artefact metadata and checksums of
                        the jars. The &attic;-core binary contains just the core &attic;
                        code without the dependencies on other Cardiff projects. The &attic;-all
                        binary includes the dependencies and is therefore ready to run as is.
                    </para>
                </listitem>
            </itemizedlist>


        </sect2>
    </sect1>
    <sect1 xml:id="sect-message">
        <title>Message Handling Components</title>

        <para>&attic; is insulated from the HTTP implementation via a set of interfaces for
            sending and receiving data and control messages. These are based on the concept of
            <code>InChannels</code>
            and<code>OutChannels</code>, and components that receive
            messages and data from
            <code>InChannels</code>
            and send data and messages to
            <code>OutChannels</code>. Figure
            <xref linkend="fig-channel"/>
            shows the classes
            involved in the channel interfaces.
            <figure xml:id="fig-channel"
                    xreflabel="Channel Interfaces">
                <title>Channel Interfaces</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata fileref="images/channel.png" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
            A
            <code>ChannelFactory</code>
            is used to create in and out channels. an
            <code>InChannel</code>
            takes a
            <code>ChannelRequestHandler</code>
            as an argument
            during creation. Request handlers receive messages along with metadata about the message
            when something arrives at the<code>InChannel</code>. Specifically, the handler receives
            a
            <code>ChannelData</code>
            object (not shown below for brevity). A
            <code>ChannelData</code>
            object is a Java bean containing a number getters and
            setter such as the request endpoint, the request data object, the response data object,
            the
            <code>Action</code>
            of the request (one of the HTTP methods) and an
            <code>Outcome</code>, mapped to the HTTP response status code.
            <code>ChannelData</code>
            is used at both the server-side, by a
            <code>ChannelRequestHandler</code>
            as well as at the client-side. On the client-side
            the application asks a factory to create an<code>OutChannel</code>, creates using the
            desired endpoint, puts some data in it and calls the channel's
            <code>send(ChannelData)</code>
            method. This returns synchronously containing
            (possibly the same)
            <code>ChannelData</code>
            object with outcome and response data in
            it.
        </para>
        <para>Being based on HTTP, the design follows a typical HTTP architecture in which different
            handlers are mapped to different URL paths (note the
            <code>getPath()</code>
            method of
            the
            <code>ChannelRequestHandler</code>
            interface. Apart from this, a handler handles a
            request using the
            <code>handleRequest(ChannelData)</code>
            method.
        </para>


        <para>Extending the
            <code>ChannelRequestHandler</code>
            is the
            <code>AbstractRequestHandler</code>
            class. This provides some functionality for
            handler implementations, in particular breaking the request into HTTP method actions.
            Hence subclasses of this abstract class do not have to work out what the request type
            is. Instead, they can process messages directly, much in the way that an extension of
            abstract
            <code>HttpServlet</code>
            can, in a Servlet framework.
        </para>
        <note>
            <para>
                <code>ChannelData</code>
                has an action called
                <varname>CREATE</varname>
                and an
                action called<varname>MESSAGE</varname>. Likewise, the
                <code>AbstractRequestHandler</code>
                has a
                <code>handleMessage</code>
                and a
                <code>handleCreate</code>
                method. Both these actions and methods map to an HTTP
                POST method. The semantics of an HTTP POST are sometimes application dependent,
                specifically if the application is tunneling data via an HTTP envelope as SOAP
                typically does. Currently the code does not distinguish between the two. Every POST
                is passed as a
                <varname>CREATE</varname>
                action. This could change.
            </para>
        </note>
        <para>The existing extensions the
            <code>AbstractRequestHandler</code>
            are shown in Figure
            <xref linkend="fig-handlers"/>. Their roles are enumerated below:
            <itemizedlist>
                <listitem>
                    <para>
                        <code>ConfigRequestHandler</code>
                        handles requests for managing the Web
                        configuration. It responds to the GET method by returning the Web form, and
                        responds to POSTs from the Web form.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>DescriptionRequestHandler</code>
                        handles requests for metadata,
                        specifically
                        <code>DataDescriptions</code>
                        and
                        <code>FileHashes</code>
                        (more
                        on these later).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>DataRequestHandler</code>
                        handles requests for data. It deals only
                        with GET methods at the moment. There is the possibility that it could
                        handle queries in the for of an HTTP POST. This would allow clients to
                        specify bandwidth constraints on data delivery by the server.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>PointerReqestHandler</code>
                        handles requests dealing with
                        <code>DataPointers</code>,
                        <code>DataAdverts</code>
                        and
                        <code>DataQueries</code>. There is a fair amount of decision making to
                        be done with these types, so this handler delegates most of the logic to an
                        <code>AdvertProcessor</code>
                        (see below).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>SeedRequestHandler</code>
                        handles receiving requests to publish data.
                        Typically a data publisher will act as a seed itself, but this is not always
                        the case. A publisher may push data to a node prepared to receive both a
                        <code>DataAdvert</code>
                        and the associated data. The seed then becomes
                        the publisher itself, passing the
                        <code>DataAdvert</code>
                        to the network and
                        storing the data locally.
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>You will notice from the class diagram that some handlers implement the
            <code>Authenticating</code>
            interface. This interface is used to specify a request
            action that is being performed by the client, based on the request path. These actions
            are mapped to identities, specifically the Distinguished Name of the client's X509
            certificate. The security implementation is discussed in more detail in the
            <link
                    xl:href="#sect-security">security
            </link>
            section. Actions include things like
            <varname>PUBLISH</varname>
            and<varname>CACHE</varname>.
        </para>
        <para>
            <figure xml:id="fig-handlers" xreflabel="Handlers">
                <title>Handlers</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata fileref="images/handlers.png" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </para>

        <para>The other core interface alongside
            <code>ChannelRequestHandler</code>
            is the
            <code>Role</code>
            interface. The classes related to this interface are shown in
            Figure<xref linkend="fig-roles"/>. A
            <code>Role</code>
            has a reference to an
            instance of an
            <code>&attic;</code>
            object. This is the central point of entry for
            an application, providing the glue between configuration options and different
            <code>Roles</code>. A
            <code>Role</code>
            is initialized with an instance of
            <code>&attic;</code>. It does not expose any service capabilities, although
            strictly speaking, it could. The basic implementation of a Worker node implements the
            <code>Role</code>
            interface. The worker does not require any running servers. It
            merely makes client requests.
        </para>
        <para>Extending the
            <code>Role</code>
            interface is the
            <code>ServiceRole</code>
            interface.
            This is designed for nodes that provide a service to the network. As well as extending
            <code>Role</code>, it also extends<code>ChannelRequestHandler</code>. Therefore it
            binds an instance of
            <code>&attic;</code>
            with the server-side message receiving
            interfaces. A
            <code>ServiceRole</code>
            is designed to create a channel and register as a
            handler with it, but to delegate the processing to other handlers based on the request
            path and the path of its registered handlers. You will notice the
            <code>addChannelRequestHandler</code>
            method, which allows a service to add
            arbitrary handlers to its own path to provide capabilities.
        </para>
        <para>The
            <code>AbstractServiceRole</code>
            provides some core methods for services to
            extend. In particular, it knows how to work out which registered
            <code>ChannelRequestHandler</code>
            should be invoked, based on the request path of
            the<code>ChannelData</code>, as well as checking that the authentication key of the
            handler, if it returns one based on the request path, is compatible with the identity
            that is making the request. This allows subclasses to know that, if the request gets as
            far as them, then the requesting agent has been authorized and authenticated. Note the
            <code>addIndentity</code>
            and
            <code>removeIdentity</code>
            methods defined by
            <code>ServiceRole</code>. More on these in the
            <link xl:href="#sect-security"
                    >security
            </link>
            section.
        </para>
        <para>The
            <code>ServiceRole</code>
            also exposes two methods for determining the endpoint
            (URL) of itself and the handlers it has registered.
        </para>
        <para>There are two further interfaces currently defined that extend
            <code>ServiceRole</code>:
        </para>
        <para>
            <figure xml:id="fig-roles" xreflabel="Roles">
                <title>Roles</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata fileref="images/roles.png" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>

        </para>

        <para>Two further extensions to the
            <code>ServiceRole</code>
            interface are currently
            defined. The
            <code>Publisher</code>
            interface is implemented by roles that initiate data
            onto the network. The
            <code>index(DataDescription, File)</code>
            takes metadata, and maps
            this to a file, producing hashed chunk descriptions in the process, and potentially
            storing the metadata. A publisher typically creates an authoritative metadata
            description which is registered with the network and downloaded by caching and worker
            nodes. Registration happens via the
            <code>publish(DataAdvert)</code>
            method. The
            <code>createEndpoint(DataAdvert)</code>
            generates an endpoint that can be inserted
            into the<code>DataAdvert</code>. Different publishers may have different policies and
            ways of generating endpoints that appear in adverts. The
            <code>getEndpoint(DataPointer)</code>
            method returns where on the network a
            <code>DataPointer</code>
            can be found. Typically, the publisher discovers this
            during the process of publishing.
        </para>
        <para>The
            <code>AdvertProcessor</code>
            interface is implemented by nodes that receive
            <code>DataAdverts</code>
            and
            <code>DataQueries</code>
            during their message
            processing. Typically, this is a role taken on by a Data Lookup Service. The two methods
            receive and advert or query, and the
            <code>ChannelData</code>
            used for the request. It
            is the responsibility of the
            <code>AdvertProcessor</code>
            to manipulate the
            <code>ChannelData</code>
            and set the response data and outcome of it.
        </para>
        <para>Please see the
            <link xl:href="#sect-message-types">Message Types</link>
            section for
            more details on how the various data structures are used.
        </para>
        <sect2>
            <title>Registering Roles with an &attic; Instance</title>
            <para>The
                <code>Role</code>
                interface exposes methods that attach it to an instance of
                an<code>&attic;</code>. The
                <code>init(&attic;)</code>
                is called to pass
                an instance of
                <code>&attic;</code>
                to the role, providing it with a central
                point to retrieve configuration information, and allow the role to launch any
                components it needs to in order to fulfill its tasks. Similarly, the
                <code>shutdown</code>
                method is used to close down any components and clean up.
                While these methods can be called directly on
                <code>Role</code>
                implementations,
                this is not recomended, in particular because the &attic; instance itself needs
                initializing at some point. Instead, client code should create an instance of
                <code>&attic;</code>
                and call the
                <code>attach</code>
                method on it, passing
                in the role, and a string identifying it. Then, by calling the
                <code>init</code>
                method on the
                <code>&attic;</code>
                instance, the role's
                <code>init</code>
                method
                will be called within that, at the correct time of initialization. The same goes for
                the
                <code>shutdown</code>
                method of<code>&attic;</code>. See Section
                <link
                        xl:href="#sect-examples">Examples
                </link>
                for examples on creating roles.
            </para>
        </sect2>
    </sect1>

    <sect1 xml:id="sect-message-types">
        <title>Message Types</title>
        <para>There a number of message types used to allow describing, publishing, and querying
            data. These are simple Java bean types. They are currently serialized to wire as
            Javascript Object Notation (<link xl:href="http://www.json.org/" xl:show="new"
                    >JSON</link>) by default. XML and XHTML is also supported. JSON messages are between 1/3 and
            1/2 smaller than XML. That's the reason for using JSON. XHTML is not recommended for
            machine to machine communication because it is quite verbose. But it will be returned by default
            to a request that specifies and Accept HTTP header with text/html as a preferred response type.
            This is typical of browsers.
        </para>
        <para>
            <note>
                <para>The current implementation supports XML, XHTML and JSON within the same network. In
                    other words one node may generate JSON messages and another may generate XML
                    messages, and they can still communicate. But changing the serialization of
                    message types on the same node will disrupt the storage of description files on
                    disk (if the default disk storage of metadata is being used) because these a serialized to disk using the current serialization
                    mechanism. Therefore, if this changes, then the stored descriptions will not be
                    understood. This bug will be resolved shortly.
                </para>
            </note>
            The different message types and their usage is described below.
            <variablelist>
                <varlistentry>
                    <term>DataDescription</term>
                    <listitem>
                        <para>This type defines metadata about some data, for example a name,
                            description, project associated with the data. It also contains an
                            identifier. This must be a globally unique id. This may actually change,
                            if &attic; adopts a hierarchical file system. A description also
                            contains a
                            <code>FileHash</code>
                        </para>
                        <variablelist>
                            <varlistentry>
                                <term>FileHash</term>
                                <listitem>
                                    <para>This type defines metadata about some data at the byte
                                        level. Specifically it contains the length of the data and
                                        an MD5 hash of the bytes. It may also contain a list
                                        <code>FileSegmentHash</code>
                                        objects.
                                    </para>
                                    <variablelist>
                                        <varlistentry>
                                            <term>FileSegmentHash</term>
                                            <listitem>
                                                <para>This describes a portion of data including the
                                                    start offset and end offset in bytes as well as an
                                                    MD5 hash of the portion. A segment is created by a
                                                    minter of a
                                                    <code>DataDescription</code>
                                                    who
                                                    decides how big segments should be.
                                                </para>
                                            </listitem>
                                        </varlistentry>
                                    </variablelist>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>DataAdvert</term>
                    <listitem>
                        <para>A
                            <code>DataAdvert</code>
                            is used to
                            <emphasis>publish</emphasis>
                            the
                            existence of data and the host who has that data. It is used by both
                            publishing agents, and caching agents. A caching agent is one that has
                            previously retrieved information about data (in the form of a
                            <code>DataPointer</code>), has downloaded the data, and is notifying
                            the network that it now has the data. This type contains a
                            <code>DataDescription</code>, an endpoint, as well as optional
                            <code>Constraints.</code>
                            A minter (e.g. a publisher) of a
                            <code>DataDescription</code>
                            should include a
                            <code>FileHash</code>
                            including segment hashes. When a caching agent notifies the network that
                            it has cached the data, then these details are not needed, because
                            agents can match against id of the<code>DataDescription</code>.
                        </para>
                        <variablelist>
                            <varlistentry xml:id="id-constraints">
                                <term>Constraints</term>
                                <listitem>
                                    <para>These are simple properties that can be added to a
                                        <code>DataAdvert</code>. They have a
                                        <varname>Type</varname>, one of
                                        <varname>String</varname>,<varname>Date</varname>,
                                        <varname>Integer</varname>,<varname>Double</varname>,
                                        <varname>Long</varname>
                                        or<varname>Boolean</varname>, as
                                        well as a string key and string value. Currently, matching
                                        on these is very primitive, in fact almost non-existent, and
                                        is on the TODO list.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>DataQuery</term>
                    <listitem>
                        <para>This type is used to query for data. Like the<code>DataAdvert</code>,
                            this can contain
                            <code>Constraints</code>
                            to restrict the types of data
                            that are received from the query. The response to a
                            <code>DataQuery</code>
                            is a<code>PointerCollection</code>. A pointer
                            collection contains one or more<code>DataPointers</code>. A
                            <code>DataAdvert</code>
                            may contain information that is not
                            necessarily intended for public consumption, in particular the
                            constraints. This is why adverts are not returned when agents query for
                            data, but
                            <code>DataPointers</code>
                            instead. Hence, logically, a
                            <code>DataPointer</code>
                            is created or amended when an advert is
                            received by an agent that also responds to<code>DataQueries</code>,
                            i.e., one that issues
                            <code>DataPointers</code>
                            on request.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>PointerCollection</term>
                    <listitem>
                        <para>This type is simply a list of<code>DataPointers</code>.
                        </para>
                        <variablelist>
                            <varlistentry xml:id="id-pointer">
                                <term>DataPointer</term>
                                <listitem>
                                    <para>This type contains a
                                        <code>DataDescription</code>
                                        and list
                                        of<code>Endpoints</code>. These are the endpoints from
                                        which the data can be retrieved. It is generated by services
                                        that have received any number of
                                        <code>DataAdverts</code>
                                        corresponding to a particular<code>DataDescription</code>.
                                        It is up to the client to decide which endpoints to use and
                                        which to forego.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Endpoint</term>
                    <listitem>
                        <para>This type is essentially a URI, but it can also contain another URI
                            within it. When an endpoint appears in a
                            <code>DataPointer</code>
                            or
                            <code>DataAdvert</code>, it may contain a
                            <varname>meta</varname>
                            URI. This is URI from which metadata about the data the main URI points
                            to can be retrieved. This allows clients to query the particular
                            endpoint to find out what segments it has. Currently two query strings
                            are supported, which, when appended to the meta URI return slightly
                            different data.
                        </para>
                        <para>The first is<varname>filehash</varname>, which returns the
                            <code>FileHash</code>
                            of a description referenced by the query
                            value.
                            <example>
                                <title>FileHash query to the meta endpoint
                                    http://www.example.org/attic/meta
                                </title>
                                <programlisting>http://www.example.org/attic/meta?filehash={description-id}</programlisting>
                            </example>
                        </para>
                        <para>The second is<varname>description</varname>, and returns a
                            representation of a full<code>DataDescription</code>.
                            <example>
                                <title>DataDescription query to the meta endpoint
                                    http://www.example.org/attic/meta
                                </title>
                                <programlisting>http://www.example.org/attic/meta?description={description-id}</programlisting>
                            </example>
                        </para>
                        <para>The current implementation also supports path variants of these, i.e.,
                            http://www.example.org/attic/meta/description/{description-id} and
                            http://www.example.org/attic/meta/filehash/{description-id}, although
                            this is not considered officially supported.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </para>
        <para>How these messages are used is described in
            <link xl:href="#sect-roles">Role
                Implementations
            </link>
        </para>
    </sect1>


    <sect1 xml:id="sect-roles">
        <title>Role Implementations</title>
        <para>The way roles are defined in the interfaces and utility implementations of
            <code>ServiceRole</code>
            and
            <code>ChannelRequestHandler</code>
            means there is a lot
            of flexibility in how the different capabilities are combined to create nodes that
            perform particular services to the network. This is to allow for flexible network
            conditions. For example, in a centralized system, there may be a single authorized node
            that performs the registration and exposure of published data. In a decentralized
            network, on the other hand, nodes may publish their data to their neighbours, or a
            federation of look up services. These differences infer that the logic implemented by
            nodes may vary, in terms of security and the roles that nodes need to support.
        </para>
        <para>Figure
            <xref linkend="fig-role-impl"/>
            shows the currently implemented Roles. These
            include:
            <variablelist>
                <varlistentry>
                    <term>DataWorker</term>
                    <listitem>
                        <para>This component knows how to pull data given a remote endpoint. This
                            endpoint should point to a
                            <code>DataPointer</code>
                            document. It
                            implements the
                            <code>DataReceiver</code>
                            interface which is notified
                            when data has finished downloading. It does not support any persistent
                            services other than the configuration service described next.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>ConfigServiceRole</term>
                    <listitem>
                        <para>The Web configuration service can be attached to an &attic;
                            instance to provide online configuration. This runs on the default port
                            of 28842 unless the port number has been set in the configuration
                            itself. It is available at the absolute path
                            <varname>/attic/config</varname>
                            on the host it is running on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>DataPublisher</term>
                    <listitem>
                        <para>The
                            <code>DataPublisher</code>
                            component can index local files and
                            publish
                            <code>DataAdverts</code>
                            given a bootstrap endpoint which to
                            publish to. It implements the
                            <code>Publisher</code>
                            interface on top of
                            extending<code>AbstractServiceRole</code>. Indexing involves taking
                            a File or Directory and a template
                            <code>DataDescription</code>
                            specifying things like project and description, and creating a full
                            description with data chunk hashes. During the process of indexing the
                            any files being indexed are renamed to the identified of the data
                            description, and by default the description is written to disk, to allow
                            the mapping between a file and a description to be discovered again on
                            start up. The default location to put files to be indexed is
                            <code>&home;/&lt;role&gt;/data</code>
                            where
                            <code>role</code>
                            is the role of the component storing data. For a
                            data publisher this is<code>dp</code>, for a data center, this
                            <code>dc</code>
                            and for a worker this is<code>dw</code>. The default
                            location for writing out matching data descriptions is
                            &home;/&lt;role&gt;/desc. So for example, if the &attic;
                            home directory is<code>~/.attic</code>, which is the default on
                            Unix-like machines, then the data directory for a publisher would be
                            <code>~/.attic/dp/data</code>
                            and the directory in which
                            descriptions are stored would be
                            <code>~/.attic/dp/desc</code>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>DataSeed</term>
                    <listitem>
                        <para>The
                            <code>DataSeed</code>
                            component extends the
                            <code>DataPublisher</code>
                            by adding a
                            <code>SeedRequestHandler</code>
                            to its list of message handlers. A
                            seed handler allows remote clients to push data to it. This data is then
                            published by the seed. The handler first accepts a
                            <code>DataDescription</code>
                            which is expected to be a template,
                            that is, excluding a list of segments. The identifier, if present, will
                            also be overwritten. In response to receipt of a description, the seed
                            handler returns an endpoint on the seed node of where to send the actual
                            data. The client then uses an HTTP POST to send the data. When the seed
                            has received the data, it publishes the data description to its lookup
                            service as a
                            <code>DataAdvert</code>
                            containing an endpoint on the seed
                            node. In return it gets an endpoint to a
                            <code>DataPointer</code>
                            from
                            the lookup service. The seed then forwards this to the client.
                            <note>
                                <para>Currently the seed returns an
                                    <code>attic</code>
                                    or
                                    <code>attics</code>
                                    URL to the client. These URL schemes are
                                    used to allow transparent data access from an endpoint
                                    referencing a
                                    <code>DataPointer</code>
                                    document. The
                                    <code>attic</code>
                                    scheme is used for non-secured endpoints
                                    (HTTP) and the
                                    <code>attics</code>
                                    scheme is used for secured
                                    (HTTPS) endpoints. By changing the scheme of the URL to its HTTP
                                    variant will allow normal retrieval of the data pointer from the
                                    remote endpoint.
                                </para>
                            </note>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>DataLookup</term>
                    <listitem>
                        <para>This component acts as a look up service for other nodes. It
                            implements the
                            <code>AdvertProcessor</code>
                            interface on top of
                            extending<code>AbstractServiceRole</code>. In particular it accepts
                            requests to publish
                            <code>DataAdverts</code>
                            and requests to cache data
                            via<code>DataQueries</code>. The current implementation provides the
                            path
                            <code>/dl/meta/pointer</code>
                            to which requests to publish and
                            cache should be directed via a POST request, e.g.
                            <code>https://example.org:8080/dl/meta/pointer</code>. This is the
                            <emphasis>publish URL</emphasis>
                            When a caching agent has downloaded
                            data, it notifies the lookup service with a
                            <code>DataAdvert</code>
                            in a
                            POST request. The endpoint to which this is directed is the endpoint of
                            the existing pointer to which it wants to add its own endpoint, e.g.,
                            <code>https://example.org:8080/dl/meta/pointer/1234567890</code>.
                            This is the<emphasis>pointer URL</emphasis>. When a
                            <code>DataLookup</code>
                            receives a publish request containing a
                            <code>DataAdvert</code>
                            the implementation does the following:
                            <itemizedlist>
                                <listitem>
                                    <para>If the request is directed at the
                                        <emphasis>publish URL
                                        </emphasis>
                                        and no matching
                                        <code>DataAdvert</code>
                                        is found
                                        in the local cache, then the
                                        <code>DataAdvert</code>
                                        is
                                        cached and a new
                                        <code>DataPointer</code>
                                        is created from
                                        the description and the endpoint in the advert. If a
                                        matching
                                        <code>DataAdvert</code>
                                        is found locally, then an
                                        associated local
                                        <code>DataPointer</code>
                                        will also exist.
                                        If this is the case, then this is a request to update, or
                                        re-publish the<code>DataPointer</code>. The
                                        <code>DataDescription</code>
                                        in the
                                        <code>DataAdvert</code>
                                        is copied to the local
                                        <code>DataPointer</code>, as well as the endpoint in the
                                        advert. Existing endpoints in the pointer are
                                        <emphasis>not</emphasis>
                                        removed. The assumption is made
                                        that the data being referenced by the advert and pointer has
                                        not changed. Otherwise a new
                                        <code>DataAdvert</code>
                                        should
                                        be published. Updating, or republishing an advert is subject
                                        to ownership constraints. Ownership of a
                                        <code>DataAdvert</code>
                                        is currently expressed by via
                                        the identity defined on a secure connection, that is, the
                                        identity of requester as determined by the certificate being
                                        used in the communication is mapped to the advert at publish
                                        time. If an update is requested, and an identity is mapped
                                        to an advert, and the update request does not contain an
                                        identity (i.e., is not performed over a secure connection),
                                        or the supplied identity does not match, then the update
                                        will fail. If the identities match, then the request has
                                        come from the minter of the
                                        <code>DataAdvert</code>
                                        and
                                        therefore has authority to manipulate the metadata. Note
                                        that deleting an advert, and hence the
                                        <code>DataPointer</code>
                                        associated with it can also
                                        only be done if the initial advert was published using an
                                        identity and the request to delete has a matching identity.
                                    </para>
                                    <para>These constraints are overridden if the &attic;
                                        security configuration
                                        <code>setTestMode</code>
                                        property is
                                        set to true. (See section
                                        <link xl:href="#sect-config"
                                                >Configuration
                                        </link>
                                        for more details.
                                    </para>

                                </listitem>
                                <listitem>
                                    <para>If the request is directed at the<emphasis>pointer
                                        URL</emphasis>, then a mapped
                                        <code>DataPointer</code>
                                        should already be cached by the lookup service. If not, an
                                        error is returned. Otherwise, the endpoint in the
                                        <code>DataAdvert</code>
                                        is added to the endpoints in the
                                        extant<code>DataPointer</code>.
                                    </para>
                                    <para>To remove itself from the list of endpoints in a
                                        particular pointer, an agent can send a
                                        <code>DataAdvert</code>
                                        with a constraint key of
                                        <varname>dereference</varname>
                                        and a value of "true".
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>When the implementation encounters a
                                        <code>DataQuery</code>, it expects the query to be
                                        directed at the<emphasis>publish URL</emphasis>, not a
                                        <emphasis>pointer URL</emphasis>. This is because a
                                        request to cache is for any data, not a particular file. The
                                        term
                                        <emphasis>any</emphasis>
                                        is qualified by the
                                        <code>Constraints</code>
                                        set on the query itself. The
                                        response to a
                                        <code>DataQuery</code>
                                        is a
                                        <code>PointerCollection</code>. This is a list of
                                        <code>DataPointers</code>
                                        that match the query. As
                                        mentioned previously, matching and constraints are still
                                        under specified and not implemented fully. The main
                                        constraint that is currently implemented is the
                                        <varname>replica</varname>
                                        constraint on a advert. This
                                        value restricts the number of times a data pointer is issued
                                        in response to a query. Other than that a very simple
                                        equality match is currently made between advert constraints
                                        and query constraints, so for example, if both share a
                                        <varname>project</varname>
                                        constraint with a string type
                                        this is equal, then the query will match the advert.
                                        Constraints have types (see above) which will be used to
                                        express slightly better matching semantics, for example
                                        <emphasis>before</emphasis>
                                        and
                                        <emphasis>after</emphasis>
                                        for date types, and
                                        <emphasis>less than</emphasis>
                                        and
                                        <emphasis>more than
                                        </emphasis>
                                        for number types.
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </para>
                        <para/>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>DataCenter</term>
                    <listitem>
                        <para>A data center acts as a client in that it requests data pointers from
                            a look up service, and downloads the data from the endpoints described
                            in the pointers. But a data center does not typically process ant data,
                            but simply caches it. It therefore sends a
                            <code>DataAdvert</code>
                            to
                            the look up service once it has downloaded the data, in the hope that
                            the look up service will add its endpoint to the relevant
                            <code>DataPointer</code>. Data centers are also the nodes that send
                            <code>DataQueries</code>
                            to the look up service, and hence receive a
                            list of
                            <code>DataPointers</code>
                            in response to the query.
                        </para>
                    </listitem>

                </varlistentry>
            </variablelist>
        </para>

        <para>
            <figure xml:id="fig-role-impl" xreflabel="Role Implementations">
                <title>Role Implementations</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata fileref="images/roles-impl.png" align="center"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </para>
    </sect1>

    <sect1 xml:id="sect-download">
        <title>Downloading</title>
        <para>The downloading code is the most complicated section of code in &attic;. The aim
            of the design is to be as extensible as possible considering the various dependencies
            and relationships between components, because the richness of features that could be
            added is almost unlimited.
        </para>


        <para>The process of downloading data begins with a<code>DataPointer</code>. As described in
            section<link xl:href="#sect-message-types">Message Types</link>, a
            <code>DataPointer</code>
            contains a metadata description and a list of endpoints
            that have the data associated with the data. The first step in the download process is
            to contact all the endpoints that expose a
            <varname>meta</varname>
            URL along with the
            data URL. A query is sent to the
            <varname>meta</varname>
            URL for a list of the hashed
            segments the host has. This series of queries is performed by a
            <code>RequestResolver</code>. The output of the process results in a
            <code>RequestCollection</code>. This is a list of
            <code>EndpointRequest</code>
            objects. An
            <code>EndpointRequest</code>
            is a mapping of many hashed segments to a
            single host. A
            <code>RequestCollection</code>
            orders the requests according to the RTT
            time of the request for hashed segments. Endpoints that did not supply a
            <varname>meta</varname>
            endpoint are added as reserve mappings to the collection and
            used as a lst resort during downloading. Hence, not supplying a
            <varname>meta</varname>
            endpoint results in the host always being far down the list of potential endpoints. This
            mechanism is used by the seed component to deprioritize itself.
        </para>


        <para>downloading data based on a
            <code>RequestCollection</code>
            is done using a
            <code>Downloader</code>
            instance.
            <code>Downloader</code>
            takes, or creates a
            <code>DownloadTableCreator</code>
            instance. A
            <code>DownloadTableCreator</code>
            takes a
            <code>RequestCollection</code>
            and creates a
            <code>DownloadTable</code>
            from it.
            This table contains contains a queue of
            <code>SegmentRequest</code>
            objects. These are
            mappings of a single endpoint to a single hashed segment as defined in the data
            description document in the original<code>DataPointer</code>. They also contain a list
            of sub-segments. These sub-segments are the actual chunks that are downloaded and may be
            smaller than the hashed segment defined in the description.
            <code>SegmentRequests</code>
            are prioritized using the policy of the table creator and a
            <code>SegmentRequestComparator</code>
            implementation that is supported by the
            <code>DownloadTable</code>
            instance being created.
        </para>

        <para>Once a
            <code>DownloadTable</code>
            instance is available, the downloader uses
            implementations of the
            <code>AbstractRequestor</code>
            to remove
            <code>SegmentRequests</code>
            from the table's queue. The amount of concurrent
            threads performing download is determined by the
            <code>getMaxFileConnections</code>
            configuration parameter of the &attic; download config (see<link
                    xl:href="#sect-config">Configuration section</link>). When a requestor has completed
            the download of a sub-segment contained in a<code>SegmentRequest</code>, it notified the
            table of either success or failure. Depending on policy, a retry may be attempted, or an
            alternative endpoint with the same hashed segment is located in the table and used to
            complete the download. This process continues until the status of the data being rebuilt
            matches the status of the data as defined during construction of the
            <code>RequestCollection</code>. If a full set of hashed segments was attainable from
            the endpoints provided in the
            <code>DataPointer</code>
            then the
            <varname>COMPLETE</varname>
            status should be achieved during download. If a table
            cannot achieve the initial status, and the table is exhausted, with no more possible
            endpoints to download from, then the table completes anyway, leaving the downloaded data
            in an unfinished state, returning an appropriate status such as
            <varname>DISCONTINUOUS</varname>, signalling that there are gaps in the downloaded
            data, or<varname>CONTINUOUS</varname>, meaning data is either missing from the beginging
            of the data, or the end of it.
        </para>

        <para>From an application perspective, downloading is done by passing a
            <code>RequestCollection</code>, and an instance of the
            <code>DataReceiver</code>
            interface to a downloader and then calling its
            <code>download()</code>
            method. The
            <code>DataReceiver</code>
            receives notification when download has completed.
        </para>

        <programlisting>

            public interface DataReceiver {

            public void dataArrived(DataEvent event);

            }
        </programlisting>

        <para>A class diagram showing the main components involved in downloading is available<link
                xl:href="images/download.pdf" xl:show="new">here</link>.
        </para>
    </sect1>

    <sect1 xml:id="sect-config">
        <title>Configuration</title>
        <para>An instance of &attic; comes with a set of configuration classes dealing with
            different aspects of the system. These are listed below. Readers are encouraged to look
            at the source code for the particular properties exposed by the configurations.
            <itemizedlist>
                <listitem>
                    <para>
                        <code>org.atticfs.config.security.SecurityConfig</code>
                        which deals with
                        security related configuration.
                        <itemizedlist>
                            <listitem>
                                <para>
                                    <code>setSecure(boolean):void</code>
                                </para>
                                <para>Whether to use secure connections or not (i.e., HTTP or
                                    HTTPS).
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>setRequireClientAuthentication(boolean):void</code>
                                </para>
                                <para>Whether or not to require clients to authenticate themselves
                                    with a certificate if using secure connections.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>addKeyStore(Keystore keystore):void</code>
                                </para>
                                <para>Add a keystore (local private key and matching public
                                    certificate in a Java keystore) to the security config. When a
                                    secure socket is created, then the local keystores are used to
                                    locate a certificate for the local peer. &attic; uses the
                                    standard Java mechanism for storing keys and certificates in
                                    <emphasis>keystore</emphasis>
                                    files. The
                                    <code>org.atticfs.config.security.Keystore</code>
                                    class is a
                                    container for data relating to a Java keystore. It includes
                                    properties for specifying the location of the keystore, (i.e. a
                                    file path), the keystore password, key password, keystore alias,
                                    keystore type and encryption algorithm. An
                                    <code>org.atticfs.config.security.Keystore</code>
                                    can also
                                    be mapped to an authority (host/port combination). This allows
                                    different keys to be used depending on the port the server is
                                    running on. A value of
                                    <code>default</code>
                                    means the keystore
                                    will be used for any connections that do not specify a host and
                                    port matching the current endpoint.
                                </para>

                            </listitem>
                            <listitem>
                                <para>
                                    <code>addTrustStore(Keystore keystore):void</code>
                                </para>
                                <para>Similar to the
                                    <code>addKeystore</code>
                                    method, this adds a
                                    trust keystore. These are used when creating a secure socket.
                                    The certificate of the remote peer is matched against
                                    certificates in the trust stores. A certificate will be allowed
                                    if it appears in the trust store, or is signed by a certificate
                                    in the trust store. By default &attic; also trusts the
                                    default certificate authorities that ship with the current Java
                                    installation.
                                </para>

                            </listitem>
                            <listitem>
                                <para>
                                    <code>setTestMode(boolean testMode)</code>
                                </para>
                                <para>Primarily designed for debugging, this allows the deletion and
                                    updating of pointer metadata without the need for an identity to
                                    be provided in the request. Default is false. It also supports
                                    the listing of all data pointers currently stored by a lookup
                                    service, wrapped in a
                                    <code>PointerCollection</code>
                                    container.
                                </para>
                            </listitem>

                        </itemizedlist>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>org.atticfs.config.data.DataConfig</code>
                        which deals with data
                        related configuration, for example setting hashed chunk sizes and specifying
                        how much local disk space should be provided to &attic; for data
                        storage.
                        <itemizedlist>
                            <listitem>
                                <para>
                                    <code>setMaxLocalData(long maxLocalData)</code>
                                </para>
                                <para>Set the total amount of space (in bytes) that &attic; is
                                    allowed to use on downloaded data. This is relevent for data
                                    center nodes in particular. The default is 100GB
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>setFileSegmentHashSize(int fileSegmentHashSize)</code>
                                </para>
                                <para>Set the size (in bytes) that hashed segments of data should
                                    be. The default is 1/2 MB.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>setDataQueryInterval(long dataQueryInterval)</code>
                                </para>
                                <para>Sets the interval between querying for data in seconds. This
                                    is used particularly by data center nodes. The default is 1
                                    hour.
                                </para>
                            </listitem>


                        </itemizedlist>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>org.atticfs.config.download.DownloadConfig</code>
                        which deals with
                        download related configuration, for example how many threads to allow per
                        download.
                        <itemizedlist>
                            <listitem>
                                <para>
                                    <code>setStreamToTargetFile(boolean streamToTargetFile)</code>
                                </para>
                                <para>If set to<varname>true</varname>, then when downloading,
                                    interim files will not be created during download. Instead data
                                    will be written directly to the final file. Downloaded blocks
                                    that do not pass verification are marked as invalidated portions
                                    of the final file until a segment download for that file
                                    succeeds.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>setBufferSize(int bufferSize)</code>
                                </para>
                                <para>Sets the in-memory buffer size while downloading.</para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>setMaxTotalConnections(int maxTotalConnections)</code>
                                </para>
                                <para>Sets the maximum total connections (i.e. threads) allowed by a
                                    client during downloading.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>setMaxFileConnections(int maxFileConnections)</code>
                                </para>
                                <para>Sets the maximum total connections (i.e. threads) allowed by a
                                    client per file.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>setConnectionIdleTime(int connectionIdleTime)</code>
                                </para>
                                <para>Sets the idle time on open connections. This is used at the
                                    server side to close connectins that have been left open by
                                    clients. The default is 3 minutes.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>setDownloadChunkSize(int downloadChunkSize)</code>
                                </para>
                                <para>Sets the size of chunks to download. These are typically
                                    smaller than hashed chunks as defined in the metadata. This
                                    means multiple smaller chanuks are downloaded before a single
                                    hashed chunk of data can be verified. The default is 256Kb.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>setRetryCount(int retryCount)</code>
                                </para>
                                <para>Sets the amount of times a failed download for a chunk is
                                    retried (from the same server). The default is 2.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>org.atticfs.config.stream.StreamConfig</code>
                        which deals with
                        streaming related configuration, for example whether to attempt verification
                        of chunks before returning them to the application. This is used by the
                        <code>AtticConnection</code>
                        class that extends
                        <code>URLConnection</code>
                        and is used for the
                        <code>attic</code>
                        URL
                        scheme.
                        <itemizedlist>
                            <listitem>
                                <para>
                                    <code>setAttemptVerification(boolean attemptVerification)</code>
                                </para>
                                <para>Set whether to attempt verification of data before passing it
                                    to the application stream. Actual verification is dependent on
                                    the hashed chunk size defined in the data description of the
                                    data being downloaded, and the size of the im-memory buffer
                                    described below.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <code>setMaxBufferSize(int maxBufferSize)</code>
                                </para>
                                <para>Sets the maximum in-memory buffering of streaming data. If
                                    this value is greater than or equal to the size of hashed chunks
                                    in the data, and attempt verification is set to true, then data
                                    will be verified before passing it to the application stream.
                                    Verification failures will be retried.
                                </para>
                            </listitem>
                        </itemizedlist>
                        <note>
                            <para>If you are using &attic; simply as a URL protocol handler,
                                then you can set these properties directly on the
                                <code>AtticConnection</code>
                                class using the
                                <code>URLConnection</code>
                                method
                                <code>setRequestProperty(String, key, String value).</code>
                                The
                                memory buffer key is
                                <code>org.atticfs.protocol.attic.max.inmemory.buffer</code>
                                and
                                the verification attempt key is
                                <code>org.atticfs.protocol.attic.attempt.verification</code>.
                                The values can be given as strings, i.e., for the int
                                <varname>10</varname>, "10" and for the boolean
                                <varname>true</varname>, "true".
                            </para>
                        </note>
                    </para>
                </listitem>
                <listitem>
                    <para><code>org.atticfs.config.html.HtmlConfig</code>. This class wraps the
                        above configuarion objects and exposes them via an HTML interface. It is
                        used by the
                        <code>ConfigServiceRole</code>
                        and
                        <code>ConfigRequestHandler</code>
                        to expose a Web interface to the
                        configuration options. This interface is typically available at the path
                        <code>/attic/config</code>
                        on a running instance of &attic;
                    </para>
                </listitem>
            </itemizedlist>
        </para>
    </sect1>

    <sect1 xml:id="sect-security">
        <title>Security</title>
        <para>Security in &attic; is currently implemented using TLS and mutual authentication
            with X509 certificates. &attic; requires Java
            <emphasis>keystores</emphasis>
            to be
            available at runtime containing local keys and certificates, as well as trusted
            certificates. These can be set using the security configuration options.
        </para>
        <para>While signed certificates provide authentication of an entity, they do not allow for
            more fine grained authorization of actions based on the identity in the certificate. To
            achieve this, &attic; uses a mapping between an application-level defined action,
            and a distinguished name (common name, organization, country etc.) as defined in a
            certificate.
        </para>
        <para>The
            <code>ServiceRole</code>
            interface, as described in Section
            <link
                    xl:href="#sect-message">Message Handling Components
            </link>
            exposes an
            <code>addIdentity</code>
            and
            <code>removeIdentity</code>
            method. The
            <code>Identity</code>
            interface encapsulates a unique identity, an object that is
            used to determine the authenticity of the identity, along with a list of roles
            supported, or allowed, by the identity. Two implementations currently exist -
            <code>X509Identity</code>
            and<code>DNIdentity</code>. The first of these is is used
            when a message arrives at a service. The
            <code>ChannelData</code>
            is populated with the
            remote certificate and local certificate (if any) being used during the transaction.
            These can be retrieved using the
            <code>ChannelData</code>
            methods
            <code>getRemoteIdentity</code>
            and
            <code>getLocalIdentity</code>
            respectively. The
            <code>DNIdentity</code>
            is currently used in the default in-memory identity store
            which stores
            <code>Identities</code>
            and their allowed roles. Equality between the
            distinguished name of the two types of
            <code>Identity</code>
            is used to determine
            whether the currently connected peer is allowed to perform a particular action. As
            described in section<link xl:href="#sect-message">Message Handling Components</link>,
            the current action is determined by querying the appropriate ChannelRequestHandler if it
            implements the
            <code>Authenticating</code>
            interface. Hence a correlation between the
            <code>Autheticating</code>
            instance's action, and the roles allowed by a particular
            <code>Identity</code>
            determine whether a peer may perform a particular request.
        </para>
        <caution>
            <para>When calling the
                <code>addIdentity</code>
                or
                <code>removeIdentity</code>
                methods
                of<code>ServiceRole</code>, be sure to do this after the
                <code>init(&attic;)</code>
                has been called. Typically this should be after
                calling the
                <code>init</code>
                method of the current &attic; instance.
            </para>
        </caution>

    </sect1>

    <sect1 xml:id="sect-persist">
        <title>Persistence</title>
        <para>The core code does not support persistence in any serious form.
            <code>DataDescriptions</code>
            are saved to disk, as are configuration properties.
            Other than that, the default implementations use in-memory storage for caching
            identities and the various messages exchanged. This is largely suitable for client-side
            nodes such as workers, or service nodes that are transient.
        </para>
        <para>There are various types of storage defined. Different implementations of stores can be
            set on the role implementations, allowing for more sophisticated storage scenarios. The
            storage interfaces are defined in the
            <code>org.atticfs.store</code>
            package. A brief
            enumeration of the interfaces is given below. Developers are asked to look at the source
            code for details of the methods defined by the interfaces.
            <itemizedlist>
                <listitem>
                    <para>
                        <code>DataAdvertStore</code>
                        - This manages storage of adverts. As part of
                        this, it is capable of mapping an identity to an advert, thus providing
                        access to the authorized publisher of an advert. It also receives
                        notification when an advert is propagated to the network by the owner of the
                        store.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>DataQueryStore</code>
                        - This manages storage of queries. It also
                        receives notification when a query has been propagated to the network in
                        some way by the owner of the store.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>DataPointerStore</code>
                        - This manages storage of data pointers as
                        well as the mapping between adverts and pointers. For example, the methods
                        to add and update a
                        <code>DataPointer</code>
                        take a
                        <code>DataAdvert</code>
                        as a parameter.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>DescriptionStore</code>
                        - This manages storage of
                        <code>DataDescriptions</code>
                        and files associated with them. It also provides access to
                        <code>FileHash</code>
                        objects associated with descriptions.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>DataPointerLocationStore</code>
                        - This maps
                        <code>DataPointers</code>
                        received by clients (e.g., publishers, data centers) to where they can be
                        located on the network.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>IdentityStore</code>
                        - This stores
                        <code>Identity</code>
                        objects.
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>In order to develop implementations of the interfaces described above, the following
            Java classes must be mapped to persistent entities in some way. Most of these are part
            of the
            <code>types</code>
            package that contains data types that are sent over the wire.
            However, implementations may want wrap these types in container classes for persistence
            to retain further data.For example the current implmentation keeps a track of how many
            times a data pointer has been propagated to the network and maps this back to the
            <varname>replica</varname>
            constraint of the associated data advert.
            <itemizedlist>
                <listitem>
                    <para><code>java.io.File</code>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>org.atticfs.types.DataDescription</code>
                        and its contained objects
                        <code>org.atticfs.types.FileHash</code>
                        and<code>
                        org.atticfs.types.FileSegmentHash</code>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>org.atticfs.types.DataAdvert</code>
                        and its contained objects
                        <code>org.atticfs.types.DataDescription</code>,
                        <code>org.atticfs.types.Endpoint</code>
                        and
                        <code>org.atticfs.types.Constraints</code>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>org.atticfs.types.DataQuery</code>
                        and its contained object
                        <code>org.atticfs.types.Constraints</code>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>org.atticfs.types.DataPointer</code>
                        and its contained objects
                        <code>org.atticfs.types.DataDescription</code>
                        and
                        <code>org.atticfs.types.Endpoint</code>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <code>org.atticfs.identity.Identity</code>
                        implementations. Currently
                        defined implementations are
                        <code>org.atticfs.impl.identity.X509Identity</code>, which is associated
                        with an X509 certificate, and
                        <code>org.atticfs.impl.identity.DNIdentity</code>
                        which is associated
                        with a distinguished name.
                    </para>
                </listitem>
            </itemizedlist>
        </para>

    </sect1>

    <sect1 xml:id="sect-examples">
        <title>Examples</title>
        <para>The following code snippets provide examples of how to run the &attic; code for
            various purposes. The examples below are largely taken from the
            <code>org.atticfs.roleservices.run</code>
            and
            <code>org.atticfs.roleservices.protocol</code>
            package
            of the source distribution.
        </para>

        <example>
            <title>&attic; URL handler</title>
            <para>This registers the adics URL schemes, then creates a URL to a
                <code>DataPointer</code>, and then opens the stream and writes the contents to
                file.
            </para>
            <programlisting>
                // register the attic: and attics: (secure) URL schemes
                // NOTE: this will not destroy existing mappings.
                AtticProtocol.registerAttic();
                // The URL should point to a DataPointer
                URL url = new URL("attic://www.example.org:9876/dl/meta/pointer/1234567890");
                File file = new File("out.dat");
                // open the stream
                InputStream in = url.openStream();
                FileOutputStream fout = new FileOutputStream(file);
                byte[] bytes = new byte[8192];
                int c;
                while ((c = in.read(bytes)) != -1) {
                fout.write(bytes, 0, c);
                }
                fout.flush();
                fout.close();
                in.close();
            </programlisting>
        </example>

        <example>
            <title>Creating a
                <code>DataWorker</code>
                and downloading data.
            </title>
            <para>This also attaches a configuration service handler to provide Web configuration.</para>

            <programlisting>
                Attic = new Attic();
                attic.setRole(StringConstants.ROLE_DW);
                ConfigServiceRole confService = new ConfigServiceRole();
                attic.attach("attic", confService);
                DataWorker dw = new DataWorker();
                attic.attach(StringConstants.DATA_WORKER, dw);
                attic.init();
                try {
                dw.getPointer(new Endpoint("https://example.org/dl/meta/pointer"));
                } catch (IOException e) {
                e.printStackTrace();
                }
            </programlisting>
        </example>

        <example>
            <title>Creating a
                <code>DataLookup</code>
                service.
            </title>
            <para>This also create a configuration handler to provide Web configuration. The
                mechanism for creating other roles pretty much the same, although some roles require
                an bootstrap (looup service) endpoint.
            </para>
            <programlisting>
                Attic attic = new Attic();
                attic.setRole(StringConstants.ROLE_DL);
                attic.attach("attic", new ConfigServiceRole());
                DataLookup dl = new DataLookup();
                attic.attach(StringConstants.DATA_LOOKUP, dl);
                attic.init();
            </programlisting>
        </example>

        <example>
            <title>Creating a
                <code>DataCenter</code>
                with a particular query interval.
            </title>
            <para>Note the setting of a bootstrap endpoint from which pointers can be retrieved.
                This is typically a lookup service endpoint, e.g.,
                https://example.org/dl/meta/pointer
            </para>
            <programlisting>
                Attic attic = new Attic();
                attic.setRole(StringConstants.ROLE_DC);
                attic.getDataConfig().setDataQueryInterval(120);
                attic.setBootstrapEndpoint("https://example.org/dl/meta/pointer");
                DataCenter dc = new DataCenter();
                attic.attach(StringConstants.DATA_CENTER, dc);
                attic.init();
            </programlisting>
        </example>

        <example>
            <title>Creating an &attic; supporting multiple roles</title>
            <programlisting>
                Attic attic = new Attic();
                attic.addRole(StringConstants.ROLE_DC);
                attic.getDataConfig().setDataQueryInterval(120);
                attic.setBootstrapEndpoint("https://example.org/dl/meta/pointer");
                DataCenter dc = new DataCenter();
                attic.attach(StringConstants.DATA_CENTER, dc);
                attic.addRole(StringConstants.ROLE_DL);
                DataLookup dl = new DataLookup();
                attic.attach(StringConstants.DATA_LOOKUP, dl);
                attic.init();
            </programlisting>
        </example>

        <example>
            <title>Creating a Secured
                <code>DataSeed</code>
            </title>
            <para>This maps two keystores to a default authority. The trust store contains the CA
                root certificate. Any clients who have a certificate signed by this ca will be able
                to perform actions that are subject to DN name authorization. It then adds two DNs
                mapped to the
                <code>CACHE</code>
                action. These DNs belong to Data centers that are
                allowed to query for cached data from the seed.
            </para>
            <programlisting>
                Attic attic = new Attic();
                attic.setBootstrapEndpoint("https://example.org/dl/meta/pointer");
                attic.addRole(StringConstants.ROLE_DS);
                DataSeed dataSeed = new DataSeed();
                attic.attach(StringConstants.DATA_PUBLISHER, dataSeed);

                // set up keystores and security config.
                // These are stored, so actually this doesn't have to be done on every start up
                SecurityConfig sc = attic.getSecurityConfig();
                sc.setSecure(true);
                sc.setRequireClientAuthentication(true);
                URL trustUrl = getClass().getClassLoader().getResource("keystores/trust.keystore");
                String trust = trustUrl.toString();
                Keystore ts = new Keystore(trust, "ca-keystore-password", "ca-keystore-alias");
                ts.setName(key + "-trust.properties");
                sc.addTrustStore(ts);
                URL keyUrl = getClass().getClassLoader().getResource("keystores/seed-key.keystore");
                String keystore = keyUrl.toString();
                Keystore ks = new Keystore(keystore, "seed-keystore-password", "seed-keystore-alias");
                ks.setName("seed-key.properties");
                sc.addKeyStore(ks);

                attic.init();

                // NOTE: adding DN names after init method
                dataSeed.addIdentity("CN=machine1.example.org, OU=attic, O=Example, L=Cardiff, ST=Wales, C=UK",
                StringConstants.CACHE_KEY);
                dataSeed.addIdentity("CN=machine2.example.org, OU=attic, O=Example, L=Cardiff, ST=Wales, C=UK",
                StringConstants.CACHE_KEY);
            </programlisting>
        </example>

        <example>
            <title>XML rendering of a DataAdvert</title>

            <programlisting>
                &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                &lt;DataAdvert xmlns="http://atticfs.org"&gt;
                &lt;DataDescription xmlns="http://p2p-adics.org"&gt;
                &lt;id&gt;12c667d6-2d5d-4904-9c2c-6746251b81ef&lt;/id&gt;
                &lt;name&gt;04Orange.mp3&lt;/name&gt;
                &lt;project&gt;Colours&lt;/project&gt;
                &lt;description&gt;Miles on Orange&lt;/description&gt;
                &lt;FileHash&gt;
                &lt;hash&gt;661c7f5e462be8ced9a8a6d8a1c7e6&lt;/hash&gt;
                &lt;size&gt;12407432&lt;/size&gt;
                &lt;Segment&gt;
                &lt;hash&gt;bedbfd11fa5fb4fd6b97349f45b6b3&lt;/hash&gt;
                &lt;start&gt;0&lt;/start&gt;
                &lt;end&gt;524287&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;8c8414acf8f15420fbb2ad5c531bb3&lt;/hash&gt;
                &lt;start&gt;524288&lt;/start&gt;
                &lt;end&gt;1048575&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;b280eb92b757899b82e081b810c7f5&lt;/hash&gt;
                &lt;start&gt;1048576&lt;/start&gt;
                &lt;end&gt;1572863&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;2fd8783ec76edb168ccbbcbe8326cdee&lt;/hash&gt;
                &lt;start&gt;1572864&lt;/start&gt;
                &lt;end&gt;2097151&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;13beab083dbcee8f58fae2274bc8&lt;/hash&gt;
                &lt;start&gt;2097152&lt;/start&gt;
                &lt;end&gt;2621439&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;7715255bdf9fedfb53b427e9b7edc&lt;/hash&gt;
                &lt;start&gt;2621440&lt;/start&gt;
                &lt;end&gt;3145727&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;27328f8c53fb05869dc33045e7078&lt;/hash&gt;
                &lt;start&gt;3145728&lt;/start&gt;
                &lt;end&gt;3670015&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;1e43ade4d9c04e5b13b4583319c546ba&lt;/hash&gt;
                &lt;start&gt;3670016&lt;/start&gt;
                &lt;end&gt;4194303&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;2ca28e60dab78dc2111a488726df41f9&lt;/hash&gt;
                &lt;start&gt;4194304&lt;/start&gt;
                &lt;end&gt;4718591&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;5553dca5b9638a8ae3b89b1cd5566&lt;/hash&gt;
                &lt;start&gt;4718592&lt;/start&gt;
                &lt;end&gt;5242879&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;1a28cd99cfaae2ec5ddbc2371d56ba71&lt;/hash&gt;
                &lt;start&gt;5242880&lt;/start&gt;
                &lt;end&gt;5767167&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;aa239f8aeb12839ab89fde66c6788ae&lt;/hash&gt;
                &lt;start&gt;5767168&lt;/start&gt;
                &lt;end&gt;6291455&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;8a10fdf1d2db2465f46cfc6957e5421&lt;/hash&gt;
                &lt;start&gt;6291456&lt;/start&gt;
                &lt;end&gt;6815743&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;d4c7ac60f67e9bded695ca9a625cbb2&lt;/hash&gt;
                &lt;start&gt;6815744&lt;/start&gt;
                &lt;end&gt;7340031&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;aae1ff17dd8b9f753bf9294f915f599c&lt;/hash&gt;
                &lt;start&gt;7340032&lt;/start&gt;
                &lt;end&gt;7864319&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;ede210539640afb878d9bc312aec59f&lt;/hash&gt;
                &lt;start&gt;7864320&lt;/start&gt;
                &lt;end&gt;8388607&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;23eee99dd034504728409ba19352f2dc&lt;/hash&gt;
                &lt;start&gt;8388608&lt;/start&gt;
                &lt;end&gt;8912895&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;252abbaf437e7a10d34aab551293d3&lt;/hash&gt;
                &lt;start&gt;8912896&lt;/start&gt;
                &lt;end&gt;9437183&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;e6b1536d6bfe88d8189d94293ab84590&lt;/hash&gt;
                &lt;start&gt;9437184&lt;/start&gt;
                &lt;end&gt;9961471&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;1099a22c9fa4423c46c6fd39e1689e0&lt;/hash&gt;
                &lt;start&gt;9961472&lt;/start&gt;
                &lt;end&gt;10485759&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;d7beadebad9a912a5ef9fdfcd25cd176&lt;/hash&gt;
                &lt;start&gt;10485760&lt;/start&gt;
                &lt;end&gt;11010047&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;a0d19f13ec8416a4c2d38426707f7&lt;/hash&gt;
                &lt;start&gt;11010048&lt;/start&gt;
                &lt;end&gt;11534335&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;12686ee83e4fbe664f44cae14e95&lt;/hash&gt;
                &lt;start&gt;11534336&lt;/start&gt;
                &lt;end&gt;12058623&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;Segment&gt;
                &lt;hash&gt;32ce5368d98243a2a9abeccc2ddc5c&lt;/hash&gt;
                &lt;start&gt;12058624&lt;/start&gt;
                &lt;end&gt;12407431&lt;/end&gt;
                &lt;/Segment&gt;
                &lt;/FileHash&gt;
                &lt;/DataDescription&gt;
                &lt;Constraints&gt;
                &lt;Constraint type="Date"&gt;
                &lt;key&gt;expires&lt;/key&gt;
                &lt;value&gt;Thu, 01 Jan 1970 00:00:01 GMT&lt;/value&gt;
                &lt;/Constraint&gt;
                &lt;Constraint type="Integer"&gt;
                &lt;key&gt;replica&lt;/key&gt;
                &lt;value&gt;3&lt;/value&gt;
                &lt;/Constraint&gt;
                &lt;/Constraints&gt;
                &lt;/DataAdvert&gt;
            </programlisting>
        </example>

        <example>
            <title>JSON rendering of a DataAdvert</title>

            <programlisting>
                <![CDATA[
 {
    "DataAdvert": {
        "DataDescription": {
            "id": "b426c41b-d5a3-4138-93ec-60a8be2a6c0c",
            "name": "04Orange.mp3",
            "project": "Colours",
            "description": "Miles on Orange",
            "location": null,
            "FileHash": {
                "hash": "661c7f5e462be8ced9a8a6d8a1c7e6",
                "size": 12407432,
                "Segment": [
                    {
                        "hash": "bedbfd11fa5fb4fd6b97349f45b6b3",
                        "start": 0,
                        "end": 524287 
                    },
                    {
                        "hash": "8c8414acf8f15420fbb2ad5c531bb3",
                        "start": 524288,
                        "end": 1048575 
                    },
                    {
                        "hash": "b280eb92b757899b82e081b810c7f5",
                        "start": 1048576,
                        "end": 1572863 
                    },
                    {
                        "hash": "2fd8783ec76edb168ccbbcbe8326cdee",
                        "start": 1572864,
                        "end": 2097151 
                    },
                    {
                        "hash": "13beab083dbcee8f58fae2274bc8",
                        "start": 2097152,
                        "end": 2621439 
                    },
                    {
                        "hash": "7715255bdf9fedfb53b427e9b7edc",
                        "start": 2621440,
                        "end": 3145727 
                    },
                    {
                        "hash": "27328f8c53fb05869dc33045e7078",
                        "start": 3145728,
                        "end": 3670015 
                    },
                    {
                        "hash": "1e43ade4d9c04e5b13b4583319c546ba",
                        "start": 3670016,
                        "end": 4194303 
                    },
                    {
                        "hash": "2ca28e60dab78dc2111a488726df41f9",
                        "start": 4194304,
                        "end": 4718591 
                    },
                    {
                        "hash": "5553dca5b9638a8ae3b89b1cd5566",
                        "start": 4718592,
                        "end": 5242879 
                    },
                    {
                        "hash": "1a28cd99cfaae2ec5ddbc2371d56ba71",
                        "start": 5242880,
                        "end": 5767167 
                    },
                    {
                        "hash": "aa239f8aeb12839ab89fde66c6788ae",
                        "start": 5767168,
                        "end": 6291455 
                    },
                    {
                        "hash": "8a10fdf1d2db2465f46cfc6957e5421",
                        "start": 6291456,
                        "end": 6815743 
                    },
                    {
                        "hash": "d4c7ac60f67e9bded695ca9a625cbb2",
                        "start": 6815744,
                        "end": 7340031 
                    },
                    {
                        "hash": "aae1ff17dd8b9f753bf9294f915f599c",
                        "start": 7340032,
                        "end": 7864319 
                    },
                    {
                        "hash": "ede210539640afb878d9bc312aec59f",
                        "start": 7864320,
                        "end": 8388607 
                    },
                    {
                        "hash": "23eee99dd034504728409ba19352f2dc",
                        "start": 8388608,
                        "end": 8912895 
                    },
                    {
                        "hash": "252abbaf437e7a10d34aab551293d3",
                        "start": 8912896,
                        "end": 9437183 
                    },
                    {
                        "hash": "e6b1536d6bfe88d8189d94293ab84590",
                        "start": 9437184,
                        "end": 9961471 
                    },
                    {
                        "hash": "1099a22c9fa4423c46c6fd39e1689e0",
                        "start": 9961472,
                        "end": 10485759 
                    },
                    {
                        "hash": "d7beadebad9a912a5ef9fdfcd25cd176",
                        "start": 10485760,
                        "end": 11010047 
                    },
                    {
                        "hash": "a0d19f13ec8416a4c2d38426707f7",
                        "start": 11010048,
                        "end": 11534335 
                    },
                    {
                        "hash": "12686ee83e4fbe664f44cae14e95",
                        "start": 11534336,
                        "end": 12058623 
                    },
                    {
                        "hash": "32ce5368d98243a2a9abeccc2ddc5c",
                        "start": 12058624,
                        "end": 12407431 
                    } 
                ] 
            } 
        },
        "Constraints": {
            "Constraint": [
                {
                    "type": "Date",
                    "key": "expires",
                    "value": "Thu, 01 Jan 1970 00:00:01 GMT" 
                },
                {
                    "type": "Integer",
                    "key": "replica",
                    "value": "3" 
                } 
            ] 
        } 
    }
}
]]>
            </programlisting>
        </example>


    </sect1>


</article>









